/**
 * modelFactory makes working with RESTful APIs in AngularJS easy
 * @version v0.1.4 - 2014-12-17
 * @link https://github.com/phxdatasec/model-factory
 * @author Austin McDaniel <amcdaniel2@gmail.com>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
!function(){"use strict";!function(global,factory){"function"==typeof define&&define.amd?define(["angular","uri-templates"],factory):"undefined"!=typeof module&&module.exports?module.exports=factory():global.ModelFactory=factory(angular,UriTemplate)}(this,function(angular,UriTemplate){var module=angular.module("modelFactory",[]),forEach=angular.forEach,extend=angular.extend,copy=angular.copy,instanceKeywords=["$$array","$save","$destroy","$pending","$revert","$diff","$extend"],staticKeywords=["actions","instance","list","defaults","pk","stripTrailingSlashes","map"],extendDeep=function(dst){return forEach(arguments,function(obj){obj!==dst&&forEach(obj,function(value,key){-1===instanceKeywords.indexOf(key)&&(dst[key]&&angular.isObject(dst[key])?extendDeep(dst[key],value):angular.isFunction(dst[key])||(dst[key]=value))})}),dst};module.provider("$modelFactory",function(){var provider=this;provider.defaultOptions={prefix:"",pk:"id",stripTrailingSlashes:!0,defaults:{},map:{},actions:{base:{wrap:!0,beforeRequest:void 0,afterRequest:void 0,cache:!1},get:{method:"GET"},query:{method:"GET",isArray:!0},post:{method:"POST",invalidateCache:!0},update:{method:"PUT",invalidateCache:!0},"delete":{method:"DELETE",invalidateCache:!0}},instance:{},list:{}},provider.$get=["$http","$q","$log","$cacheFactory",function($http,$q,$log,$cacheFactory){function modelFactory(url,options){function ModelCollection(value){value=value||[],value.forEach(function(v,i){null!==v&&void 0!==v&&(value[i]=wrapAsNewModelInstance(v,value))});var __oldPush=value.push;return value.push=function(){for(var args=Array.prototype.slice.call(arguments),i=0;i<args.length;i++)args[i]=wrapAsNewModelInstance(args[i]);__oldPush.apply(value,args)},options.list&&extend(value,options.list),value}function Model(value){var instance=this,commits=[];value=value||{},forEach(options.defaults,function(v,k){void 0===value[k]&&(value[k]="function"==typeof v?v(value):v)}),forEach(options.map,function(v,k){typeof v===Model||typeof v===ModelCollection?value[k]=new v(value[k]):"function"==typeof v?value[k]=v(value[k],value):(value[k]=value[k],delete value[k])}),forEach(options.actions,function(v,k){"$"===k[0]&&(instance[k]=function(){return Model.$buildRequest(k,v,instance)})}),extend(instance,value),extend(instance,copy(options.instance)),instance.$save=function(){var promise=Model[instance[options.pk]?"update":"post"](instance);return instance.$pending=!0,promise.then(function(value){instance.$pending=!1,extendDeep(instance,value)},function(){instance.$pending=!1}),promise},instance.$destroy=function(){var promise=Model.delete(instance);return instance.$pending=!0,promise.then(function(){instance.$pending=!1;var arr=instance.$$array;arr&&arr.splice(arr.indexOf(instance),1)},function(){instance.$pending=!1}),promise},instance.$diff=function(){return DeepDiff.deep(old,instance,function(path,key){return"$"===key[0]})},instance.$commit=function(){return commits.push(angular.toJson(instance)),instance},instance.$rollback=function(version){var prevCommit=commits[version||commits.length-1];return instance.$extend(JSON.parse(prevCommit)),instance},instance.$extend=function(n){return extendDeep(instance,n),instance},instance.$commit()}var promiseTracker={};options=extendDeep({},copy(provider.defaultOptions),options);var wrapAsNewModelInstance=function(rawObj,arrayInst){var inst=rawObj.constructor===Model?rawObj:new Model(rawObj);return inst.$$array=arrayInst,inst};return Model.$cache=$cacheFactory(url),forEach(options.actions,function(v,k){"base"!==k&&"$"!==k[0]&&(Model[k]=function(){var args=Array.prototype.slice.call(arguments);return Model.$buildRequest.apply(this,[k,v].concat(args))})}),Model.$buildRequest=function(action,param,data,extras){var clone=copy(options.actions.base);extend(clone,copy(param)),clone.cache===!0&&(clone.cache=Model.$cache);var uri=options.prefix?options.prefix+"/":"";if(clone.override)uri=clone.url;else if(uri+=url,clone.url&&(uri+="/"+clone.url),("get"===action||"post"===action||"update"===action||"delete"===action)&&(uri+="/{"+options.pk+"}"),"GET"===clone.method&&(angular.isString(data)||angular.isNumber(data))){var obj={};obj[options.pk]=data,data=obj,extras&&(data.param=extras,uri+="{?param*}")}else"GET"===clone.method&&angular.isObject(data)&&(data={param:data},uri+="{?param*}");return clone.url=Model.$url(uri,data),clone.data=data,Model.$call(clone)},Model.$call=function(params){var signature=params.method+":"+params.url;if(promiseTracker[signature])return promiseTracker[signature];var def=$q.defer();return promiseTracker[signature]=def.promise,params.data=copy(params.data),params.beforeRequest&&params.beforeRequest(params),params.data=Model.$strip(params.data),$http(params).success(function(response){params.afterRequest&&params.afterRequest(response),params.invalidateCache&&Model.$cache.removeAll(),def.resolve(params.wrap?params.isArray?new Model.List(response):new Model(response):response),promiseTracker[signature]=void 0}).error(function(response){promiseTracker[signature]=void 0,def.reject(response)}),def.promise},Model.$url=function(u,params){var uri=new UriTemplate(u||url).fillFromObject(params||{});return options.stripTrailingSlashes&&(uri=uri.replace(/\/+$/,"")||"/"),uri},Model.$strip=function(args){return args&&"object"==typeof args&&forEach(args,function(v,k){instanceKeywords.indexOf(k)>-1&&delete args[k]}),args},forEach(options,function(v,k){-1===staticKeywords.indexOf(k)&&(Model[k]=v)}),Model.List=ModelCollection,Model}return modelFactory}]})})}();